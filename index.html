<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8" />
      <meta http-equiv="X-UA-Compatible" content="ie=edge" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Quartz crystals</title>
      <style>
         * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -applesystem, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu,
            Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
         }
         html,
         body {
            height: 100vh;
            width: 100vw;
         }
         #threejs-container {
            position: block;
            width: 100%;
            height: 100%;
         }
         .obit-controls-gizmo {
            position: absolute;
            top: 2em;
            left: 2em;
            z-index: 1000;
            background-color: #FFF0;
            border-radius: 100%;
            transition: background-color .15s linear;
            cursor: pointer;
         }

         .obit-controls-gizmo.dragging, .obit-controls-gizmo:hover  {
            background-color: #FFF3;
            
         }

         .obit-controls-gizmo.inactive {
            pointer-events: none;
            background-color: #FFF0 !important; 
         }

      </style>
	   <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.4/jquery.min.js" ></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
      <script src="./js/non-module/dat.gui.js"></script>
	   <script src="./js/non-module/OrbitControlsGizmo.js"></script>  
	   <script src="./js/non-module/OrbitControls.js"></script>  
      
      <script src="./js/cry/quartz.js"></script>
      <script src="./js/cry/cry.js"></script>
   
   </head>
   <body>
   
      <input type="file" id="crystalInput" accept=".sfn"/>
      <div id="container"></div>
      <input class="toggle" type="checkbox" name="chkTrnsp" id="transp">
      <label for="transp">Transparency</label>
      
      <script>
         $(document).ready(function(){
       
           $("#crystalInput").change(function (event) {
             file = event.target.files[0]
             var reader = new FileReader();
             reader.onload = function (e) {
                  
              alert(e.target.result) 

              loadCrystal(e.target.result);
               };
               reader.readAsBinaryString(file);
            });
           
            $( "[name='chkTrnsp']").on( "change", handleTransp );
            });
         function handleTransp(e){
           //glTransparency =  $( "#transp").is( ":checked" );
           //drawScene();
         }
        
        
        
      </script>
     
     
     
     
     <script >
         
         let qzBlock =  new THREE.Group();
         // controls
         const gui = new dat.GUI({ autoPlace: true, width: 300 })
          
         //console.log('start')
         // sizes
         let width = window.innerWidth
         let height = window.innerHeight
         // scene
         const scene = new THREE.Scene()
         scene.background = new THREE.Color(0x262626)
         //console.log(scene.children)
         // renderer
         const renderer = new THREE.WebGL1Renderer()
         renderer.setSize(window.innerWidth, window.innerHeight)
         renderer.shadowMap.enabled = true
         renderer.shadowMap.type = THREE.PCFSoftShadowMap
         renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
         document.body.appendChild( renderer.domElement );
         
         // lights
         const ambientLight = new THREE.AmbientLight(0xffffff, 0.5)
         scene.add(ambientLight)
         const light = new THREE.DirectionalLight()
         light.position.set(2.5, 2, 2)
         light.castShadow = true
         light.shadow.mapSize.width = 512
         light.shadow.mapSize.height = 512
         light.shadow.camera.near = 0.5
         light.shadow.camera.far = 100
         scene.add(light)
         const helper = new THREE.DirectionalLightHelper(light)
         scene.add(helper)
         // light controls
         const lightColor = {
            color: light.color.getHex()
         }
         const lightFolder = gui.addFolder('Directional Light')
         lightFolder.addColor(lightColor, 'color').onChange(() => {
         light.color.set(lightColor.color)
         })
         lightFolder.add(light, 'intensity', 0, 1, 0.01)
         lightFolder.open()
         const directionalLightFolder = gui.addFolder('Position of Light')
         directionalLightFolder.add(light.position, 'x', -10, 10, 0.1)
         directionalLightFolder.add(light.position, 'y', -10, 10, 0.1)
         directionalLightFolder.add(light.position, 'z', -10, 10, 0.1)
         directionalLightFolder.open()
         // camera
         const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000)
         camera.position.set(0, 0, 10)
         const camFolder = gui.addFolder('Camera')
         camFolder.add(camera.position, 'z', 10, 80, 1)
         camFolder.open()
            
         const controls = new OrbitControls(camera, renderer.domElement)
         const controlsGizmo = new OrbitControlsGizmo(controls, { size: 100, padding: 8 });
         document.body.appendChild(controlsGizmo.domElement);

         controls.autoRotate = true
         const ocFolder = gui.addFolder('Orbit Controls')
         ocFolder.add(controls, 'enabled')
         ocFolder.add(controls, 'enableZoom')
         ocFolder.add(controls, 'enableRotate')
         ocFolder.add(controls, 'enablePan')
         ocFolder.add(controls, 'autoRotate')
         ocFolder.add(controls, 'autoRotateSpeed', 1, 100, 1)
         ocFolder.open()
          
          
         // axes Helper
         const axesHelper = new THREE.AxesHelper( 15 );
         scene.add( axesHelper );
         // // Grid Helper
         const grid = new THREE.GridHelper(10, 10, "#666666", "#222222");
         grid.position.y=-1.74;
         scene.add(grid);
         
         // plane
         
         
          // plane
         const planeGeometry = new THREE.PlaneGeometry(20, 20)  //(1000, 1000)
         const plane = new THREE.Mesh(
            planeGeometry,
            new THREE.MeshPhongMaterial({ color: 0xffffff, side: THREE.DoubleSide })
         )
         plane.rotateX(-Math.PI / 2)
         plane.position.y = -1.75
         plane.receiveShadow = true
         plane.name = "floor"
         scene.add(plane)
       

        
        
         // cube
    
         const geometry = new THREE.BoxGeometry(2, 2, 2)
         const material = new THREE.MeshStandardMaterial({
            color: 0x87ceeb
         })
         const cube = new THREE.Mesh(geometry, material);
         cube.position.set(2, 0.5, 0);
         cube.castShadow = true;
         cube.receiveShadow = true;
         cube.name ="куб";
         scene.add(cube);


		  
		   load('./crystals/TutIni.png')
		   //load('http://localhost/softQz/crystals/TutIni.sfn')
	
         function load(url) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.responseType = 'arraybuffer';
            xhr.onload = function(e) {
               if (this.status == 200) {
  	              // var uInt8Array = new Uint8Array(this.response);
                  utf8 = new TextDecoder("ascii").decode(this.response);
                  loadCrystal(utf8);
               }
            };
           xhr.send();
	      }







         let INTERSECTED, INTERSECTED_COLOR;
         const raycaster = new THREE.Raycaster();
         const pointer = new THREE.Vector2();
         
         
         window.addEventListener( 'pointermove', onPointerMove );

           
         // responsiveness
         window.addEventListener('resize', () => {
            width = window.innerWidth
            height = window.innerHeight
            camera.aspect = width / height
            camera.updateProjectionMatrix()
            renderer.setSize(window.innerWidth, window.innerHeight)
            renderer.render(scene, camera)
         })
 
    // crystal
        
   // alert("cr");
     //   loadCrystal('./crystals/Tutini.sfn');



         // animation
         function animate() {
            requestAnimationFrame(animate)
             //cube.rotation.x += 0.005
             //cube.rotation.y += 0.01
            controls.update()
            render();
            renderer.render(scene, camera)
         }
         
  
  

         function onPointerMove( event ) {
            // calculate pointer position in normalized device coordinates (-1 to +1) for both components
            pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
         }

         function render() {
            if(crShow.faceSel || INTERSECTED != null){
            
               raycaster.setFromCamera( pointer, camera );
               const intersects = raycaster.intersectObjects( qzBlock.children, false );

               if ( intersects.length > 0 ) {

                  if ( INTERSECTED != intersects[ 0 ].object ) {
                     if ( INTERSECTED ) INTERSECTED.material.color = INTERSECTED_COLOR.clone ();

                     INTERSECTED = intersects[ 0 ].object;
                     INTERSECTED_COLOR = INTERSECTED.material.color.clone ();
                     INTERSECTED.material.color.set( 0xcc7722 )
                     
                     //-------------------------------------------------
                     //if ( INTERSECTED ) console.log(INTERSECTED.name)
                     //-------------------------------------------------

                  }

               } else {
                  if ( INTERSECTED ) INTERSECTED.material.color = INTERSECTED_COLOR.clone ();
                  INTERSECTED = null;
               }            
        
            }
         }


         // rendering the scene
         const container = document.querySelector('#container')
         container.append(renderer.domElement)
         renderer.render(scene, camera)
         //window.requestAnimationFrame(render);
         animate()
         
         //console.log(scene.children)

      </script>
   </body>
</html>